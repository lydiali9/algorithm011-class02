/**
 * @param {number[]} nums
 * @return {boolean}
 */
/**
 * 思路分析：贪心算法
 * 如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。
 * 可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。
 * 如果可以一直跳到最后，就成功了。
 * 
 * 时间复杂度为O(n)
 * 空间复杂度为O(1)
 */
var canJump = function(nums) {
    let max = 0; // 表示到达的最大值（nums[i] + i）

    for (var i = 0; i < nums.length; i++) {
        if (i > max) return false;
        max = Math.max(max, nums[i] + i);
    }
    return true;
};
/**
 * 此题解法相对解法四，可以反过来，着重点从跳跳节点位置转移到跳跳距离上来做文章
栗子：[3,2,1,0,4] == nums
依次遍历(每个节点对应可跳最大距离 == i+nums[i])数组
存储第i个节点可以跳的最远的距离
遍历到第(i+1)个节点时，判断当前节点索引值是否小于上一个节点的最远距离
小于，则说明，上一个节点跳不到当前节点，更别说最后一个目标节点了，直接返回false，不可达
大于，则上一个节点至少可以跳到当前节点但不一定能跳到最后一个节点
更新上一节点最远距离
i++
循环到n后，依旧没有碰到false，说明跳到最后了，起跳点至少可以跳到末尾，甚至大于它的距离
 */